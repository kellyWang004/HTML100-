<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<link rel="stylesheet" type="text/css" href="000.css" />
		<link rel="stylesheet" type="text/css" href="reset.css" />
		<style type="text/css">
			*{
				margin: 0;
				padding: 0;
			}
			#box {
				position: relative;
				z-index: 1;
				padding: 10%;
				background-color: antiquewhite;
				display: flex;
				flex-flow: column nowrap;
				text-align: center;
				align-items: center;
			}

			input {
				margin: 10px 0px;
				width: 200px;
			}

			span {
				display: block;
				margin-top: 30px;
				line-height: 25px;
			}

			a {
				margin-top: 40px;
			}
			form{
				width: 270px;
			}
			fieldset{
				display: flex;
				flex-flow: row wrap;
				justify-content: space-between;
			}
			form input{
				width: 160px;
			}
			#explain{
				text-align: left;
			}
		</style>
	</head>
	<body>
		<div id="box">
			<span>第125关</span>
			<span>meta标签的http-equiv属性值为cache-control时，对应的content值如下：no-cache、no-store、public、private、maxage、no-siteapp。他们解释如下，请按顺序将所有content属性值对应的解释前面的序号填在输入框中，英文逗号隔开</span>
			<input type="text" name="" id="input_2" spellcheck="false" placeholder="输入序号数字" />
			<span id="explain"></span>
			<a id="a_1" href="126.html" accesskey="" hidden="hidden">下一关</a>
		</div>
		<script type="text/javascript">
			const input_2 = document.getElementById("input_2");
			const a_1 = document.getElementById("a_1");
			const span_explain = document.getElementById("explain");
			// 创建答案数组
			let answer_arr =[];
			let temp = [1,2,3,4,5,6];
			// 随机排序
			let explain_arr = ["先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。<br/>",
			"不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）<br/>",
			"缓存所有响应，但并非必须。因为max-age也可以做到相同效果。<br/>",
			"只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）。<br/>",
			"表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如该值为60表示响应可以再缓存和重用 60 秒。<br/>",
			"在移动端打开时禁止转码。<br/>"];
			// 对数组随机排序的函数
			function sortPlus (arr,arr2) {
				for(let i = 0;i<arr.length;i++){
					let a = parseInt(Math.random()*arr.length);
					let temp = arr[a];
					let temp2 = arr2[a];
					arr[a] = arr[i];
					arr[i] = temp;
					arr2[a] = arr2[i];
					arr2[i] = temp2;
				}	
			}
			sortPlus(explain_arr,temp);
			// 根据随机重排的字符串数组，写出标签解释文本的内容
			for(let i = 0;i < explain_arr.length;i++){
				span_explain.innerHTML += `${i+1}、` + explain_arr[i] + "\n";
			};
			// 根据临时数组计算出答案数组。
			for(let i = 0;i<temp.length;i++){
				 answer_arr.push(temp.indexOf(i+1,0)+1);
			};
			// 将答案数组转化为字符串
			let regValue = answer_arr.join();
			// 定义正则
			const reg = new RegExp(regValue,"ig");
			// 答案核对函数
			function Atrr2() {
				if (!(input_2.value.search(reg) === -1)) {
					clearInterval(bc);
					a_1.hidden = null;
				}
			}
			// 答案核对函数定时执行
			let bc = setInterval(Atrr2, 300);
		</script>
	</body>
</html>
